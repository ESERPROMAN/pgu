Local objectToDelete = game:GetService("ReplicatedStorage").Assets.Vfx.OneTwo
objectToDelete:Destroy()
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Knit Service Path (adjust if your Knit service path is different)
local AbilityService = ReplicatedStorage.Packages.Knit.Services.AbilityService

-- Player variable
local player = Players.LocalPlayer

-------------------------------------------------------------------------------
--! json library
--! cryptography library
local a=2^32;local b=a-1;local function c(d,e)local f,g=0,1;while d~=0 or e~=0 do local h,i=d%2,e%2;local j=(h+i)%2;f=f+j*g;d=math.floor(d/2)e=math.floor(e/2)g=g*2 end;return f%a end;local function k(d,e,l,...)local m;if e then d=d%a;e=e%a;m=c(d,e)if l then m=k(m,l,...)end;return m elseif d then return d%a else return 0 end end;local function n(d,e,l,...)local m;if e then d=d%a;e=e%a;m=(d+e-c(d,e))/2;if l then m=n(m,l,...)end;return m elseif d then return d%a else return b end end;local function o(p)return b-p end;local function q(d,r)if r<0 then return lshift(d,-r)end;return math.floor(d%2^32/2^r)end;local function s(p,r)if r>31 or r<-31 then return 0 end;return q(p%a,r)end;local function lshift(d,r)if r<0 then return s(d,-r)end;return d*2^r%2^32 end;local function t(p,r)p=p%a;r=r%32;local u=n(p,2^r-1)return s(p,r)+lshift(u,32-r)end;local v={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}local function w(x)return string.gsub(x,".",function(l)return string.format("%02x",string.byte(l))end)end;local function y(z,A)local x=""for B=1,A do local C=z%256;x=string.char(C)..x;z=(z-C)/256 end;return x end;local function D(x,B)local A=0;for B=B,B+3 do A=A*256+string.byte(x,B)end;return A end;local function E(F,G)local H=64-(G+9)%64;G=y(8*G,8)F=F.."\128"..string.rep("\0",H)..G;assert(#F%64==0)return F end;local function I(J)J[1]=0x6a09e667;J[2]=0xbb67ae85;J[3]=0x3c6ef372;J[4]=0xa54ff53a;J[5]=0x510e527f;J[6]=0x9b05688c;J[7]=0x1f83d9ab;J[8]=0x5be0cd19;return J end;local function K(F,B,J)local L={}for M=1,16 do L[M]=D(F,B+(M-1)*4)end;for M=17,64 do local N=L[M-15]local O=k(t(N,7),t(N,18),s(N,3))N=L[M-2]L[M]=(L[M-16]+O+L[M-7]+k(t(N,17),t(N,19),s(N,10)))%a end;local d,e,l,P,Q,R,S,T=J[1],J[2],J[3],J[4],J[5],J[6],J[7],J[8]for B=1,64 do local O=k(t(d,2),t(d,13),t(d,22))local U=k(n(d,e),n(d,l),n(e,l))local V=(O+U)%a;local W=k(t(Q,6),t(Q,11),t(Q,25))local X=k(n(Q,R),n(o(Q),S))local Y=(T+W+X+v[B]+L[B])%a;T=S;S=R;R=Q;Q=(P+Y)%a;P=l;l=e;e=d;d=(Y+V)%a end;J[1]=(J[1]+d)%a;J[2]=(J[2]+e)%a;J[3]=(J[3]+l)%a;J[4]=(J[4]+P)%a;J[5]=(J[5]+Q)%a;J[6]=(J[6]+R)%a;J[7]=(J[7]+S)%a;J[8]=(J[8]+T)%a end;local function Z(F)F=E(F,#F)local J=I({})for B=1,#F,64 do K(F,B,J)end;return w(y(J[1],4)..y(J[2],4)..y(J[3],4)..y(J[4],4)..y(J[5],4)..y(J[6],4)..y(J[7],4)..y(J[8],4))end;local e;local l={["\\"]="\\",["\""]="\"",["\b"]="b",["\f"]="f",["\n"]="n",["\r"]="r",["\t"]="t"}local P={["/"]="/"}for Q,R in pairs(l)do P[R]=Q end;local S=function(T)return"\\"..(l[T]or string.format("u%04x",T:byte()))end;local B=function(M)return"null"end;local v=function(M,z)local _={}z=z or{}if z[M]then error("circular reference")end;z[M]=true;if rawget(M,1)~=nil or next(M)==nil then local A=0;for Q in pairs(M)do if type(Q)~="number"then error("invalid table: mixed or invalid key types")end;A=A+1 end;if A~=#M then error("invalid table: sparse array")end;for a0,R in ipairs(M)do table.insert(_,e(R,z))end;z[M]=nil;return"["..table.concat(_,",").."]"else for Q,R in pairs(M)do if type(Q)~="string"then error("invalid table: mixed or invalid key types")end;table.insert(_,e(Q,z)..":"..e(R,z))end;z[M]=nil;return"{"..table.concat(_,",").."}"end end;local g=function(M)return'"'..M:gsub('[%z\1-\31\\"]',S)..'"'end;local a1=function(M)if M~=M or M<=-math.huge or M>=math.huge then error("unexpected number value '"..tostring(M).."'")end;return string.format("%.14g",M)end;local j={["nil"]=B,["table"]=v,["string"]=g,["number"]=a1,["boolean"]=tostring}e=function(M,z)local x=type(M)local a2=j[x]if a2 then return a2(M,z)end;error("unexpected type '"..x.."'")end;local a3=function(M)return e(M)end;local a4;local N=function(...)local _={}for a0=1,select("#",...)do _[select(a0,...)]=true end;return _ end;local L=N(" ","\t","\r","\n")local p=N(" ","\t","\r","\n","]","}",",")local a5=N("\\","/",'"',"b","f","n","r","t","u")local m=N("true","false","null")local a6={["true"]=true,["false"]=false,["null"]=nil}local a7=function(a8,a9,aa,ab)for a0=a9,#a8 do if aa[a8:sub(a0,a0)]~=ab then return a0 end end;return#a8+1 end;local ac=function(a8,a9,J)local ad=1;local ae=1;for a0=1,a9-1 do ae=ae+1;if a8:sub(a0,a0)=="\n"then ad=ad+1;ae=1 end end;error(string.format("%s at line %d col %d",J,ad,ae))end;local af=function(A)local a2=math.floor;if A<=0x7f then return string.char(A)elseif A<=0x7ff then return string.char(a2(A/64)+192,A%64+128)elseif A<=0xffff then return string.char(a2(A/4096)+224,a2(A%4096/64)+128,A%64+128)elseif A<=0x10ffff then return string.char(a2(A/262144)+240,a2(A%262144/4096)+128,a2(A%4096/64)+128,A%64+128)end;error(string.format("invalid unicode codepoint '%x'",A))end;local ag=function(ah)local ai=tonumber(ah:sub(1,4),16)local aj=tonumber(ah:sub(7,10),16)if aj then return af((ai-0xd800)*0x400+aj-0xdc00+0x10000)else return af(ai)end end;local ak=function(a8,a0)local _=""local al=a0+1;local Q=al;while al<=#a8 do local am=a8:byte(al)if am<32 then ac(a8,al,"control character in string")elseif am==92 then _=_..a8:sub(Q,al-1)al=al+1;local T=a8:sub(al,al)if T=="u"then local an=a8:match("^[dD][89aAbB]%x%x\\u%x%x%x%x",al+1)or a8:match("^%x%x%x%x",al+1)or ac(a8,al-1,"invalid unicode escape in string")_=_..ag(an)al=al+#an else if not a5[T]then ac(a8,al-1,"invalid escape char '"..T.."' in string")end;_=_..P[T]end;Q=al+1 elseif am==34 then _=_..a8:sub(Q,al-1)return _,al+1 end;al=al+1 end;ac(a8,a0,"expected closing quote for string")end;local ao=function(a8,a0)local am=a7(a8,a0,p)local ah=a8:sub(a0,am-1)local A=tonumber(ah)if not A then ac(a8,a0,"invalid number '"..ah.."'")end;return A,am end;local ap=function(a8,a0)local am=a7(a8,a0,p)local aq=a8:sub(a0,am-1)if not m[aq]then ac(a8,a0,"invalid literal '"..aq.."'")end;return a6[aq],am end;local ar=function(a8,a0)local _={}local A=1;a0=a0+1;while 1 do local am;a0=a7(a8,a0,L,true)if a8:sub(a0,a0)=="]"then a0=a0+1;break end;am,a0=a4(a8,a0)_[A]=am;A=A+1;a0=a7(a8,a0,L,true)local as=a8:sub(a0,a0)a0=a0+1;if as=="]"then break end;if as~=","then ac(a8,a0,"expected ']' or ','")end end;return _,a0 end;local at=function(a8,a0)local _={}a0=a0+1;while 1 do local au,M;a0=a7(a8,a0,L,true)if a8:sub(a0,a0)=="}"then a0=a0+1;break end;if a8:sub(a0,a0)~='"'then ac(a8,a0,"expected string for key")end;au,a0=a4(a8,a0)a0=a7(a8,a0,L,true)if a8:sub(a0,a0)~=":"then ac(a8,a0,"expected ':' after key")end;a0=a7(a8,a0+1,L,true)M,a0=a4(a8,a0)_[au]=M;a0=a7(a8,a0,L,true)local as=a8:sub(a0,a0)a0=a0+1;if as=="}"then break end;if as~=","then ac(a8,a0,"expected '}' or ','")end end;return _,a0 end;local av={['"']=ak,["0"]=ao,["1"]=ao,["2"]=ao,["3"]=ao,["4"]=ao,["5"]=ao,["6"]=ao,["7"]=ao,["8"]=ao,["9"]=ao,["-"]=ao,["t"]=ap,["f"]=ap,["n"]=ap,["["]=ar,["{"]=at}a4=function(a8,a9)local as=a8:sub(a9,a9)local a2=av[as]if a2 then return a2(a8,a9)end;ac(a8,a9,"unexpected character '"..as.."'")end;local aw=function(a8)if type(a8)~="string"then error("expected argument of type string, got "..type(a8))end;local _,a9=a4(a8,a7(a8,1,L,true))a9=a7(a8,a9,L,true)if a9<=#a8 then ac(a8,a9,"trailing garbage")end;return _ end;
local lEncode, lDecode, lDigest = a3, aw, Z;
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
--! platoboost library

--! configuration
local service = 4510;  -- your service id, this is used to identify your service.
local secret = "268be3fd-73cd-4983-95fd-0fc6cb19ddc4";  -- make sure to obfuscate this if you want to ensure security.
local useNonce = true;  -- use a nonce to prevent replay attacks and request tampering.

--! callbacks
local onMessage = function(message) end; -- This will be replaced with your showPopupMessage function

--! wait for game to load
repeat task.wait(1) until game:IsLoaded();

--! functions
local requestSending = false;
local fSetClipboard, fRequest, fStringChar, fToString, fStringSub, fOsTime, fMathRandom, fMathFloor, fGetHwid = setclipboard or toclipboard, request or http_request or syn_request, string.char, tostring, string.sub, os.time, math.random, math.floor, gethwid or function() return game:GetService("Players").LocalPlayer.UserId end
local cachedLink, cachedTime = "", 0;

--! pick host
local host = "https://api.platoboost.com";
local hostResponse = fRequest({
    Url = host .. "/public/connectivity",
    Method = "GET"
});
if hostResponse.StatusCode ~= 200 or hostResponse.StatusCode ~= 429 then
    host = "https://api.platoboost.net";
end

--!optimize 2
function cacheLink()
    if cachedTime + (10*60) < fOsTime() then
        local response = fRequest({
            Url = host .. "/public/start",
            Method = "POST",
            Body = lEncode({
                service = service,
                identifier = lDigest(fGetHwid())
            }),
            Headers = {
                ["Content-Type"] = "application/json"
            }
        });

        if response.StatusCode == 200 then
            local decoded = lDecode(response.Body);

            if decoded.success == true then
                cachedLink = decoded.data.url;
                cachedTime = fOsTime();
                return true, cachedLink;
            else
                onMessage(decoded.message);
                return false, decoded.message;
            end
        elseif response.StatusCode == 429 then
            local msg = "you are being rate limited, please wait 20 seconds and try again.";
            onMessage(msg);
            return false, msg;
        end

        local msg = "Failed to cache link.";
        onMessage(msg);
        return false, msg;
    else
        return true, cachedLink;
    end
end

cacheLink();

--!optimize 2
local generateNonce = function()
    local str = ""
    for _ = 1, 16 do
        str = str .. fStringChar(fMathFloor(fMathRandom() * (122 - 97 + 1)) + 97)
    end
    return str
end

--!optimize 1
for _ = 1, 5 do
    local oNonce = generateNonce();
    task.wait(0.2)
    if generateNonce() == oNonce then
        local msg = "platoboost nonce error.";
        onMessage(msg);
        error(msg);
    end
end

--!optimize 2
local copyLink = function()
    local success, link = cacheLink();
    
    if success then
        fSetClipboard(link);
    end
end

--!optimize 2
local redeemKey = function(key)
    local nonce = generateNonce();
    local endpoint = host .. "/public/redeem/" .. fToString(service);

    local body = {
        identifier = lDigest(fGetHwid()),
        key = key
    }

    if useNonce then
        body.nonce = nonce;
    end

    local response = fRequest({
        Url = endpoint,
        Method = "POST",
        Body = lEncode(body),
        Headers = {
            ["Content-Type"] = "application/json"
        }
    });

    if response.StatusCode == 200 then
        local decoded = lDecode(response.Body);

        if decoded.success == true then
            if decoded.data.valid == true then
                if useNonce then
                    if decoded.data.hash == lDigest("true" .. "-" .. nonce .. "-" .. secret) then
                        return true;
                    else
                        onMessage("failed to verify integrity.");
                        return false;
                    end    
                else
                    return true;
                end
            else
                onMessage("key is invalid.");
                return false;
            end
        else
            if fStringSub(decoded.message, 1, 27) == "unique constraint violation" then
                onMessage("you already have an active key, please wait for it to expire before redeeming it.");
                return false;
            else
                onMessage(decoded.message);
                return false;
            end
        end
    elseif response.StatusCode == 429 then
        onMessage("you are being rate limited, please wait 20 seconds and try again.");
        return false;
    else
        onMessage("server returned an invalid status code, please try again later.");
        return false; 
    end
end

--!optimize 2
local verifyKey = function(key)
    if requestSending == true then
        onMessage("a request is already being sent, please slow down.");
        return false;
    else
        requestSending = true;
    end

    local nonce = generateNonce();
    local endpoint = host .. "/public/whitelist/" .. fToString(service) .. "?identifier=" .. lDigest(fGetHwid()) .. "&key=" .. key;

    if useNonce then
        endpoint = endpoint .. "&nonce=" .. nonce;
    end

    local response = fRequest({
        Url = endpoint,
        Method = "GET",
    });

    requestSending = false;

    if response.StatusCode == 200 then
        local decoded = lDecode(response.Body);

        if decoded.success == true then
            if decoded.data.valid == true then
                if useNonce then
                    if decoded.data.hash == lDigest("true" .. "-" .. nonce .. "-" .. secret) then
                        return true;
                    else
                        onMessage("failed to verify integrity.");
                        return false;
                    end
                else
                    return true;
                end
            else
                if fStringSub(key, 1, 4) == "KEY_" then
                    return redeemKey(key);
                else
                    onMessage("key is invalid.");
                    return false;
                end
            end
        else
            onMessage(decoded.message);
            return false;
        end
    elseif response.StatusCode == 429 then
        onMessage("you are being rate limited, please wait 20 seconds and try again.");
        return false;
    else
        onMessage("server returned an invalid status code, please try again later.");
        return false;
    end
end

--!optimize 2
local getFlag = function(name)
    local nonce = generateNonce();
    local endpoint = host .. "/public/flag/" .. fToString(service) .. "?name=" .. name;

    if useNonce then
        endpoint = endpoint .. "&nonce=" .. nonce;
    end

    local response = fRequest({
        Url = endpoint,
        Method = "GET",
    });

    if response.StatusCode == 200 then
        local decoded = lDecode(response.Body);

        if decoded.success == true then
            if useNonce then
                if decoded.data.hash == lDigest(fToString(decoded.data.value) .. "-" .. nonce .. "-" .. secret) then
                    return decoded.data.value;
                else
                    onMessage("failed to verify integrity.");
                    return nil;
                end
            else
                return decoded.data.value;
            end
        else
            onMessage(decoded.message);
            return nil;
        end
    else
        return nil;
    end
end
-------------------------------------------------------------------------------

--- UI Setup ---
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DraggableUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 150) -- Even smaller and stretched initial UI frame
frame.Position = UDim2.new(0.5, -100, 0.5, -75) -- Adjust position for smaller frame
frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Darker black
frame.BorderSizePixel = 0
frame.Parent = screenGui

local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 10)
frameCorner.Parent = frame

local frameStroke = Instance.new("UIStroke")
frameStroke.Color = Color3.fromRGB(50, 50, 50) -- Darker stroke
frameStroke.Thickness = 2
frameStroke.Transparency = 0.5
frameStroke.Parent = frame

-- Optional: Anime girl decoration (example, you'll need an ImageLabel and an image asset)
local animeGirl = Instance.new("ImageLabel")
animeGirl.Size = UDim2.new(1, 0, 1, 0)
animeGirl.BackgroundTransparency = 1
animeGirl.Image = "rbxassetid://YOUR_ANIME_GIRL_IMAGE_ID" -- **Replace with an actual image ID**
animeGirl.ScaleType = Enum.ScaleType.Fit
animeGirl.ZIndex = 0 -- Behind other elements
animeGirl.Parent = frame

--- Dragging functionality for any UI element ---
local function makeDraggable(element)
    local dragging, dragInput, dragStart, startPos
    element.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = element.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    element.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            element.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end
makeDraggable(frame) -- Make the initial key frame draggable

--- Close Button ---
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 20, 0, 20) -- Smaller close button
closeButton.Position = UDim2.new(1, -25, 0, 5)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.new(1,1,1)
closeButton.Font = Enum.Font.GothamBold
closeButton.TextScaled = true
closeButton.Parent = frame
closeButton.ZIndex = 2 -- Ensure it's above the anime girl

local closeButtonCorner = Instance.new("UICorner")
closeButtonCorner.CornerRadius = UDim.new(0, 5)
closeButtonCorner.Parent = closeButton

closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

--- Key Box ---
local keyBox = Instance.new("TextBox")
keyBox.Size = UDim2.new(0, 180, 0, 25) -- Smaller key box
keyBox.Position = UDim2.new(0.5, -90, 0, 20) -- Adjust position
keyBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Darker
keyBox.TextColor3 = Color3.new(1,1,1)
keyBox.PlaceholderText = "Enter your key here..."
keyBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100) -- Darker placeholder
keyBox.ClearTextOnFocus = false
keyBox.Font = Enum.Font.SourceSansSemibold
keyBox.TextSize = 14 -- Smaller text
keyBox.Parent = frame
keyBox.ZIndex = 2 -- Ensure it's above the anime girl

local keyBoxCorner = Instance.new("UICorner")
keyBoxCorner.CornerRadius = UDim.new(0, 8)
keyBoxCorner.Parent = keyBox

--- Copy Key Link Button ---
local copyLinkButton = Instance.new("TextButton")
copyLinkButton.Size = UDim2.new(0, 85, 0, 30) -- Smaller button
copyLinkButton.Position = UDim2.new(0.5, -90, 0, 55) -- Adjust position
copyLinkButton.BackgroundColor3 = Color3.fromRGB(0, 80, 180) -- Darker blue
copyLinkButton.Text = "Copy Key Link"
copyLinkButton.TextColor3 = Color3.new(1,1,1)
copyLinkButton.Font = Enum.Font.GothamBold
copyLinkButton.TextSize = 12 -- Smaller text
copyLinkButton.Parent = frame
copyLinkButton.ZIndex = 2 -- Ensure it's above the anime girl

local copyLinkButtonCorner = Instance.new("UICorner")
copyLinkButtonCorner.CornerRadius = UDim.new(0, 8)
copyLinkButtonCorner.Parent = copyLinkButton

copyLinkButton.MouseButton1Click:Connect(function()
    local success, link = pcall(function()
        copyLink()
    end)
    copyLinkButton.Text = success and "Copied!" or "Failed!"
    task.wait(2)
    copyLinkButton.Text = "Copy Key Link"
end)

--- Check Button ---
local checkButton = Instance.new("TextButton")
checkButton.Size = UDim2.new(0, 85, 0, 30) -- Smaller button
checkButton.Position = UDim2.new(0.5, 5, 0, 55) -- Adjust position
checkButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60) -- Darker green
checkButton.Text = "Check Key"
checkButton.TextColor3 = Color3.new(1,1,1)
checkButton.Font = Enum.Font.GothamBold
checkButton.TextSize = 12 -- Smaller text
checkButton.Parent = frame
checkButton.ZIndex = 2 -- Ensure it's above the anime girl

local checkButtonCorner = Instance.new("UICorner")
checkButtonCorner.CornerRadius = UDim.new(0, 8)
checkButtonCorner.Parent = checkButton

--- Discord Button ---
local discordButton = Instance.new("TextButton")
discordButton.Size = UDim2.new(0, 180, 0, 100) -- Smaller button
discordButton.Position = UDim2.new(0.5, -90, 0, 100) -- Adjust position
discordButton.BackgroundColor3 = Color3.fromRGB(50, 70, 180) -- Darker blue/purple
discordButton.Text = "Join Discord"
discordButton.TextColor3 = Color3.new(1,1,1)
discordButton.Font = Enum.Font.GothamBold
discordButton.TextSize = 14 -- Smaller text
discordButton.Parent = frame
discordButton.ZIndex = 2 -- Ensure it's above the anime girl

local discordButtonCorner = Instance.new("UICorner")
discordButtonCorner.CornerRadius = UDim.new(0, 8)
discordButtonCorner.Parent = discordButton

discordButton.MouseButton1Click:Connect(function()
    local success, err = pcall(function()
        setclipboard("https://discord.gg/Wy7Mhhgn3h")
    end)
    discordButton.Text = success and "Copied!" or "Failed to copy"
    task.wait(2)
    discordButton.Text = "Join Discord"
end)

--- Variables for features ---
local hrp = nil -- HumanoidRootPart of the local player
local fixHitboxActive = false -- New variable for hitbox fix toggle
local staminaLockActive = false -- New variable for stamina lock toggle

-- New variables for GK Assist (Sphere Mode)
local gkAssistActive = false -- Renamed for clarity
local gkSpherePart = nil -- The single sphere part
local gkSphereRadius = 25 -- Sphere size 25

-- Client-side Player Gaze Line management
local clientPlayerLines = {} -- player instance -> linePart

--- Popup Message Function ---
local function showPopupMessage(text, duration, fadeTime)
    local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    gui.Name = "Popup"
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local label = Instance.new("TextLabel", gui)
    label.Size = UDim2.new(0, 250, 0, 50) -- Smaller popup
    label.Position = UDim2.new(0.5, -125, 0.05, 0)
    label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    label.BackgroundTransparency = 0.8
    label.TextColor3 = Color3.new(1, 1, 1)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 24 -- Smaller text
    label.Text = text
    label.ZIndex = 10

    local popupCorner = Instance.new("UICorner")
    popupCorner.CornerRadius = UDim.new(0, 10)
    popupCorner.Parent = label

    label.TextTransparency = 0
    label.BackgroundTransparency = 0.8

    task.wait(duration)

    local fadeOutInfo = TweenInfo.new(fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local fadeOutTween = TweenService:Create(label, fadeOutInfo, {TextTransparency = 1, BackgroundTransparency = 1})
    fadeOutTween:Play()
    fadeOutTween.Completed:Wait()

    gui:Destroy()
end

-- Set the Platoboost onMessage callback to your showPopupMessage function
onMessage = function(message)
    showPopupMessage(message, 2, 0.5) -- Use appropriate duration and fade time
end


--- Confirmation Popup Function ---
local function showConfirmationPopup(message, confirmCallback, declineCallback)
    local confirmGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    confirmGui.Name = "ConfirmationPopup"
    confirmGui.ResetOnSpawn = false
    confirmGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local confirmFrame = Instance.new("Frame")
    confirmFrame.Size = UDim2.new(0, 300, 0, 120) -- Smaller confirmation frame
    confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -60)
    confirmFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Darker black
    confirmFrame.BorderSizePixel = 0
    confirmFrame.Parent = confirmGui
    confirmFrame.ZIndex = 5

    local confirmFrameCorner = Instance.new("UICorner")
    confirmFrameCorner.CornerRadius = UDim.new(0, 10)
    confirmFrameCorner.Parent = confirmFrame

    local confirmFrameStroke = Instance.new("UIStroke")
    confirmFrameStroke.Color = Color3.fromRGB(50, 50, 50) -- Darker stroke
    confirmFrameStroke.Thickness = 2
    confirmFrameStroke.Transparency = 0.5
    confirmFrameStroke.Parent = confirmFrame

    local confirmLabel = Instance.new("TextLabel")
    confirmLabel.Size = UDim2.new(1, -20, 0, 50) -- Smaller label
    confirmLabel.Position = UDim2.new(0, 10, 0, 10)
    confirmLabel.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Darker black
    confirmLabel.BackgroundTransparency = 1
    confirmLabel.TextColor3 = Color3.new(1, 1, 1)
    confirmLabel.Font = Enum.Font.GothamBold
    confirmLabel.TextSize = 18 -- Smaller text
    confirmLabel.TextWrapped = true
    confirmLabel.Text = message
    confirmLabel.Parent = confirmFrame

    local confirmButton = Instance.new("TextButton")
    confirmButton.Size = UDim2.new(0, 90, 0, 30) -- Smaller buttons
    confirmButton.Position = UDim2.new(0.5, -100, 0, 80)
    confirmButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60) -- Darker green
    confirmButton.Text = "Confirm"
    confirmButton.TextColor3 = Color3.new(1,1,1)
    confirmButton.Font = Enum.Font.GothamBold
    confirmButton.TextSize = 14
    confirmButton.Parent = confirmFrame

    local confirmButtonCorner = Instance.new("UICorner")
    confirmButtonCorner.CornerRadius = UDim.new(0, 8)
    confirmButtonCorner.Parent = confirmButton

    local declineButton = Instance.new("TextButton")
    declineButton.Size = UDim2.new(0, 90, 0, 30) -- Smaller buttons
    declineButton.Position = UDim2.new(0.5, 10, 0, 80)
    declineButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    declineButton.Text = "Decline"
    declineButton.TextColor3 = Color3.new(1,1,1)
    declineButton.Font = Enum.Font.GothamBold
    declineButton.TextSize = 14
    declineButton.Parent = confirmFrame

    local declineButtonCorner = Instance.new("UICorner")
    declineButtonCorner.CornerRadius = UDim.new(0, 8)
    declineButtonCorner.Parent = declineButton

    confirmButton.MouseButton1Click:Connect(function()
        confirmGui:Destroy()
        if confirmCallback then
            confirmCallback()
        end
    end)

    declineButton.MouseButton1Click:Connect(function()
        confirmGui:Destroy()
        if declineCallback then
            declineCallback()
        end
    end)
end

local function onCharacterAdded(char)
    hrp = char:WaitForChild("HumanoidRootPart")
end

--- GK Assist (Sphere Mode) Functions ---
local function createGKSphere()
    if gkSpherePart and gkSpherePart.Parent then gkSpherePart:Destroy() end
    gkSpherePart = Instance.new("Part")
    gkSpherePart.Name = "GKSphereVisual"
    gkSpherePart.Anchored = true
    gkSpherePart.CanCollide = false
    gkSpherePart.Shape = Enum.PartType.Ball
    gkSpherePart.Size = Vector3.new(gkSphereRadius * 2, gkSphereRadius * 2, gkSphereRadius * 2) -- Diameter
    gkSpherePart.Material = Enum.Material.Neon
    gkSpherePart.Color = Color3.fromRGB(0, 255, 0) -- Green
    gkSpherePart.Transparency = 0.9 -- Very transparent, like hitbox
    gkSpherePart.Parent = workspace
end

local function setGKSphereVisibility(state, button)
    gkAssistActive = state -- Use the renamed variable
    if gkSpherePart then
        gkSpherePart.Transparency = state and 0.9 or 1 -- 1 makes it completely invisible
    end
    if button then
        button.Text = state and "GK Assist: On" or "GK Assist: Off" -- Renamed button text
        button.BackgroundColor3 = state and Color3.fromRGB(60, 120, 60) or Color3.fromRGB(200, 80, 0) -- Darker Orange for off
    end
end

local function updateGKSphereAndTrigger()
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    hrp = character.HumanoidRootPart

    if gkSpherePart then
        gkSpherePart.Position = hrp.Position
    end

    local football = workspace:FindFirstChild("Football")
    if football and football:IsA("BasePart") then
        -- GK Assist (Sphere Mode)
        if gkAssistActive then
            local distance = (football.Position - hrp.Position).Magnitude
            if distance <= gkSphereRadius then
                pcall(function()
                    ReplicatedStorage.Packages.Knit.Services.BallService.RE.Dive:FireServer()
                end)
            end
        end
    end
end

--- Enlarge and update hitbox constantly ---
local function updateHitbox()
    local football = workspace:FindFirstChild("Football")
    if football then
        local hitbox = football:FindFirstChild("Hitbox")
        if hitbox and hitbox:IsA("BasePart") then
            hitbox.Size = Vector3.new(25, 25, 25)
            hitbox.Transparency = 0.9
            -- If fixHitboxActive is true, lock hitbox position to football
            if fixHitboxActive then
                hitbox.CFrame = football.CFrame
            end
            hitbox.Anchored = false
        end
    end
end

--- Trail parts for showing direction ---
local trailParts = {}
local function updateTrail()
    for _, part in ipairs(trailParts) do
        if part and part.Parent then
            part:Destroy()
        end
    end
    trailParts = {}

    local ball = workspace:FindFirstChild("Football")
    if not ball or not ball:IsA("BasePart") then return end

    local velocity = ball.AssemblyLinearVelocity
    if velocity.Magnitude < 0.1 then return end

    local direction = velocity.Unit
    local startPos = ball.Position
    local trailLength = 100
    local spacing = 5

    for i = 1, trailLength do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Size = Vector3.new(0.5, 0.5, 0.5)
        part.Shape = Enum.PartType.Ball
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 255)
        part.Transparency = 0.5
        part.CFrame = CFrame.new(startPos + direction * (i * spacing))
        part.Parent = workspace
        table.insert(trailParts, part)
    end
end

--- Client-Side Player Gaze Line Functions (Targeting players with HasBall) ---

local hasBallConnections = {} -- To keep track of connections for HasBall values

local function createClientPlayerGazeLine(targetPlayer, character)
    if clientPlayerLines[targetPlayer] then return end -- Line already exists

    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not humanoidRootPart then return end

    local linePart = Instance.new("Part")
    linePart.Name = targetPlayer.Name .. "'sGazeLine_Client"
    linePart.Anchored = true
    linePart.CanCollide = false
    linePart.Transparency = 0.5
    linePart.BrickColor = BrickColor.new("Bright green") -- Distinct color for client-side lines
    linePart.FormFactor = Enum.FormFactor.Symmetric
    linePart.Size = Vector3.new(0.5, 0.5, 200)
    linePart.Parent = workspace -- Parent to workspace for visibility to THIS client
    linePart.Material = Enum.Material.Neon

    clientPlayerLines[targetPlayer] = linePart
end

local function removeClientPlayerGazeLine(targetPlayer)
    local linePart = clientPlayerLines[targetPlayer]
    if linePart and linePart.Parent then
        linePart:Destroy()
    end
    clientPlayerLines[targetPlayer] = nil
end

local function updateAllClientPlayerGazeLines()
    if not clientPlayerLines then return end

    for targetPlayer, linePart in pairs(clientPlayerLines) do
        local character = targetPlayer.Character
        -- Ensure the character and its HumanoidRootPart are still valid
        if character and character.Parent and character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = character.HumanoidRootPart
            local rootCFrame = humanoidRootPart.CFrame

            local startPosition = rootCFrame.p + rootCFrame.LookVector * 0.5
            local endPosition = rootCFrame.p + rootCFrame.LookVector * linePart.Size.Z
            linePart.CFrame = CFrame.new(startPosition, endPosition) * CFrame.new(0, 0, -linePart.Size.Z / 2)
        else
            -- If character or HumanoidRootPart is gone, clean up the line
            removeClientPlayerGazeLine(targetPlayer)
        end
    end
end

local function setupPlayerHasBallTracking(targetPlayer)
    -- Disconnect existing connections for this player to prevent duplicates
    if hasBallConnections[targetPlayer] then
        for _, conn in pairs(hasBallConnections[targetPlayer]) do
            conn:Disconnect()
        end
        hasBallConnections[targetPlayer] = nil
    end

    hasBallConnections[targetPlayer] = {}

    local function checkHasBall(char)
        if not char then return end
        local valuesFolder = char:WaitForChild("Values", 5)
        if not valuesFolder then return end

        local hasBallValue = valuesFolder:WaitForChild("HasBall", 5)
        if not hasBallValue then return end

        -- Initial check
        if hasBallValue.Value == true then
            createClientPlayerGazeLine(targetPlayer, char)
        else
            removeClientPlayerGazeLine(targetPlayer)
        end

        -- Connect to changed event
        local changedConn = hasBallValue.Changed:Connect(function(newValue)
            if newValue == true then
                createClientPlayerGazeLine(targetPlayer, char)
            else
                removeClientPlayerGazeLine(targetPlayer)
            end
        end)
        table.insert(hasBallConnections[targetPlayer], changedConn)

        -- Clean up line and connections when character is removed
        local charRemovingConn = char.AncestryChanged:Connect(function()
            if not char:IsDescendantOf(game) then
                removeClientPlayerGazeLine(targetPlayer)
                -- Disconnect all connections for this player
                if hasBallConnections[targetPlayer] then
                    for _, conn in pairs(hasBallConnections[targetPlayer]) do
                        conn:Disconnect()
                    end
                    hasBallConnections[targetPlayer] = nil
                end
            end
        end)
        table.insert(hasBallConnections[targetPlayer], charRemovingConn)
    end

    -- Connect to CharacterAdded for this player
    local charAddedConn = targetPlayer.CharacterAdded:Connect(checkHasBall)
    table.insert(hasBallConnections[targetPlayer], charAddedConn)

    -- Handle already existing character
    if targetPlayer.Character then
        checkHasBall(targetPlayer.Character)
    end
end

local function cleanupPlayerHasBallTracking(targetPlayer)
    if hasBallConnections[targetPlayer] then
        for _, conn in pairs(hasBallConnections[targetPlayer]) do
            conn:Disconnect()
        end
        hasBallConnections[targetPlayer] = nil
    end
    removeClientPlayerGazeLine(targetPlayer)
end

-- =================================================================
-- ================== NEW HUB AND FEATURES (CORE) ==================
-- =================================================================

local hubGui
local playerLineEnabled = false -- New global state for the player line feature

-- Auto Dribble Settings (integrated)
if not getgenv().AutoDribbleSettings then getgenv().AutoDribbleSettings={
    Enabled = false, -- Default to false so it's not on immediately
    range = 30
}
end
local AutoDribbleSettings = getgenv().AutoDribbleSettings

local function getLocalCharacterComponents()
    local c = player.Character or player.CharacterAdded:Wait()
    return c, c:WaitForChild("HumanoidRootPart"), c:WaitForChild("Humanoid")
end
local LocalChar, LocalHRP, LocalHumanoid = getLocalCharacterComponents()
player.CharacterAdded:Connect(function()LocalChar, LocalHRP, LocalHumanoid = getLocalCharacterComponents()end)

local DribbleEvent = ReplicatedStorage.Packages.Knit.Services.BallService.RE.Dribble
local Animations = require(ReplicatedStorage.Assets.Animations)

local function loadAnimation(animationName)
    if Animations.Dribbles[animationName] then
        local anim = Instance.new("Animation")
        anim.AnimationId = Animations.Dribbles[animationName]
        return LocalHumanoid:LoadAnimation(anim)
    end
end

local function isOpponentSlidingOrStopped(p)
    if p ~= player and p.Character then
        local c = p.Character
        local v = c:FindFirstChild("Values") and c.Values:FindFirstChild("Sliding")
        local h = c:FindFirstChildOfClass("Humanoid")
        return (v and v.Value) or (h and h.MoveDirection.Magnitude > 0 and h.WalkSpeed == 0)
    end
end

local function isOpponent(p)
    return player.Team and p.Team and player.Team ~= p.Team
end

local function performDribble(distance)
    if AutoDribbleSettings.Enabled and LocalChar and LocalChar.Values and LocalChar.Values.HasBall.Value then
        DribbleEvent:FireServer()
        local style = player.PlayerStats.Style.Value
        local animTrack = loadAnimation(style)
        if animTrack then
            animTrack:Play()
            animTrack:AdjustSpeed(math.clamp(1 + (10 - distance) / 10, 1, 2))
        end
        local football = workspace:FindFirstChild("Football")
        if football then
            football.AssemblyLinearVelocity = Vector3.new()
            football.CFrame = LocalHRP.CFrame * CFrame.new(0,-2.5,0)
        end
    end
end

-- Auto Dribble Heartbeat Loop
RunService.Heartbeat:Connect(function()
    if AutoDribbleSettings.Enabled and LocalChar and LocalHRP then
        for _,p in pairs(Players:GetPlayers())do
            if isOpponent(p) and isOpponentSlidingOrStopped(p)then
                local rootPart = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local distance = (rootPart.Position - LocalHRP.Position).Magnitude
                    if distance < AutoDribbleSettings.range then
                        performDribble(distance)
                        break -- Dribble once for the closest target
                    end
                end
            end
        end
    end
end)


-- --- AUTO FARM FEATURE START ---
local autoFarmScreenGui = nil -- Reference to the AutoFarmUI ScreenGui
local afToggleButton = nil -- Reference to the new 'af' toggle button
local lastTargetSwitchTime = tick() -- Track time of last target switch
local currentTargetIndex = 1 -- Current index in the list of selected players

local function activateAutoFarm()
    -- Only create if it doesn't exist
    if autoFarmScreenGui and autoFarmScreenGui.Parent then
        autoFarmScreenGui.Enabled = not autoFarmScreenGui.Enabled -- Toggle visibility instead of destroying
        afToggleButton.Visible = autoFarmScreenGui.Enabled -- Ensure the toggle button matches
        return -- Exit function
    end

    -- UI Configuration for Auto Farm
    local UI_REFRESH_INTERVAL = 10 -- Seconds
    local TRIGGER_INTERVAL = 0.000000000001 -- Seconds (0.1 milliseconds)
    local TARGET_SWITCH_DELAY = 1 -- Minimum 1 second before switching targets

    -- Create the UI
    autoFarmScreenGui = Instance.new("ScreenGui")
    autoFarmScreenGui.Name = "AutoFarmUI"
    autoFarmScreenGui.ResetOnSpawn = false -- Keep UI across spawns
    autoFarmScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    autoFarmScreenGui.Enabled = true -- Start enabled

    -- Main Frame (Hidden initially, toggled by the circle button)
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 200, 0, 300)
    mainFrame.Position = UDim2.new(0.5, -100, 0.5, -150) -- Centered
    mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Darker black
    mainFrame.BorderSizePixel = 0
    mainFrame.ClipsDescendants = true
    mainFrame.Parent = autoFarmScreenGui
    mainFrame.Visible = true -- Start visible when opened from hub

    -- UI Corner for Main Frame
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = mainFrame

    -- Title Bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Darker
    titleBar.Parent = mainFrame

    -- Title Label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 1, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "PGU's Auto Farm"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = 18
    titleLabel.Parent = titleBar

    -- Player List Scroll Frame
    local playerListFrame = Instance.new("ScrollingFrame")
    playerListFrame.Name = "PlayerList"
    playerListFrame.Size = UDim2.new(1, -10, 1, -90) -- Leave space for title and buttons, added padding
    playerListFrame.Position = UDim2.new(0, 5, 0, 30) -- Position below title, with padding
    playerListFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25) -- Darker
    playerListFrame.BorderSizePixel = 0
    playerListFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Adjusted by UILayout
    playerListFrame.ScrollBarThickness = 6
    playerListFrame.Parent = mainFrame

    -- UI List Layout for player buttons
    local listLayout = Instance.new("UIListLayout")
    listLayout.Name = "PlayerListLayout"
    listLayout.FillDirection = Enum.FillDirection.Vertical
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    listLayout.Padding = UDim.new(0, 5)
    listLayout.Parent = playerListFrame
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder

    -- Buttons Container Frame for bottom buttons
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Name = "ButtonContainer"
    buttonContainer.Size = UDim2.new(1, 0, 0, 75) -- Height for two rows of buttons
    buttonContainer.Position = UDim2.new(0, 0, 1, -75)
    buttonContainer.BackgroundTransparency = 1
    buttonContainer.Parent = mainFrame

    -- UI List Layout for button container
    local buttonLayout = Instance.new("UIListLayout")
    buttonLayout.Name = "ButtonLayout"
    buttonLayout.FillDirection = Enum.FillDirection.Vertical
    buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    buttonLayout.Padding = UDim.new(0, 5)
    buttonLayout.Parent = buttonContainer

    -- Select All Button
    local selectAllButton = Instance.new("TextButton")
    selectAllButton.Name = "SelectAllButton"
    selectAllButton.Size = UDim2.new(0.9, 0, 0, 20) -- Take full width of container
    selectAllButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Darker
    selectAllButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    selectAllButton.Text = "Select All"
    selectAllButton.Font = Enum.Font.SourceSansSemibold
    selectAllButton.TextSize = 14
    selectAllButton.Parent = buttonContainer

    -- Deselect All Button
    local deselectAllButton = Instance.new("TextButton")
    deselectAllButton.Name = "DeselectAllButton"
    deselectAllButton.Size = UDim2.new(0.9, 0, 0, 20)
    deselectAllButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Darker
    deselectAllButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    deselectAllButton.Text = "Deselect All"
    deselectAllButton.Font = Enum.Font.SourceSansSemibold
    deselectAllButton.TextSize = 14
    deselectAllButton.Parent = buttonContainer

    -- Loop Button
    local loopButton = Instance.new("TextButton")
    loopButton.Name = "LoopButton"
    loopButton.Size = UDim2.new(0.9, 0, 0, 20)
    loopButton.BackgroundColor3 = Color3.fromRGB(0, 100, 0) -- Darker Green when off
    loopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    loopButton.Text = "Start Loop"
    loopButton.Font = Enum.Font.SourceSansSemibold
    loopButton.TextSize = 14
    loopButton.Parent = buttonContainer

    -- UI Corner for buttons
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = selectAllButton
    buttonCorner:Clone().Parent = deselectAllButton
    buttonCorner:Clone().Parent = loopButton

    -- Variables for draggable UI
    local dragging = false
    local dragStartPos
    local dragStartMousePos

    -- Store selected players
    local selectedPlayers = {}
    local playerButtons = {}
    local isLooping = false
    local triggerConnection = nil

    -- Function to create a player button
    local function createPlayerButton(playerObj)
        local button = Instance.new("TextButton")
        button.Name = playerObj.Name
        button.Size = UDim2.new(1, 0, 0, 25)
        button.BackgroundColor3 = Color3.fromRGB(40, 40, 40) -- Darker
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Text = playerObj.Name
        button.Font = Enum.Font.SourceSans
        button.TextSize = 16
        button.Parent = playerListFrame

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = button

        button.MouseButton1Click:Connect(function()
            if selectedPlayers[playerObj.UserId] then
                selectedPlayers[playerObj.UserId] = nil
                button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            else
                selectedPlayers[playerObj.UserId] = playerObj
                button.BackgroundColor3 = Color3.fromRGB(0, 80, 160) -- Darker blue for selected
            end
        end)
        playerButtons[playerObj.UserId] = button
        return button
    end

    -- Function to refresh the player list
    local function refreshPlayerList()
        -- Clear existing buttons
        for _, button in pairs(playerListFrame:GetChildren()) do
            if button:IsA("TextButton") then
                button:Destroy()
            end
        end
        playerButtons = {} -- Reset the dictionary

        -- Add current players
        for _, playerObj in ipairs(Players:GetPlayers()) do
            if playerObj ~= Players.LocalPlayer then -- Don't include local player
                local button = createPlayerButton(playerObj)
                if selectedPlayers[playerObj.UserId] then
                    button.BackgroundColor3 = Color3.fromRGB(0, 80, 160)
                end
            end
        end

        -- Update CanvasSize after adding elements
        local contentHeight = listLayout.AbsoluteContentSize.Y
        playerListFrame.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
    end

    -- Select All functionality
    selectAllButton.MouseButton1Click:Connect(function()
        selectedPlayers = {} -- Clear previous selections
        for _, playerObj in ipairs(Players:GetPlayers()) do
            if playerObj ~= Players.LocalPlayer then
                selectedPlayers[playerObj.UserId] = playerObj
            end
        end
        refreshPlayerList() -- Re-render to show selections
    end)

    -- Deselect All functionality
    deselectAllButton.MouseButton1Click:Connect(function()
        selectedPlayers = {} -- Clear all selections
        refreshPlayerList() -- Re-render to clear selections
    end)

    -- Ability Trigger Loop functions
    local function startTriggerLoop()
        if triggerConnection then return end -- Already running
        isLooping = true
        loopButton.Text = "Stop Loop"
        loopButton.BackgroundColor3 = Color3.fromRGB(180, 0, 0) -- Darker Red when active

        triggerConnection = task.spawn(function()
            while isLooping do
                local targets = {}
                for _, playerObj in pairs(selectedPlayers) do
                    if playerObj.Character then
                        table.insert(targets, playerObj.Character)
                    end
                end

                -- Only fire if there are selected targets
                if #targets > 0 then
                    local targetChar = targets[currentTargetIndex]
                    if targetChar then
                        local args = {
                            [1] = "OneTwo",
                            [2] = targetChar -- Target the current player
                        }
                        pcall(function()
                            AbilityService.RE.Ability:FireServer(unpack(args))
                        end)
                    end

                    -- Switch to the next target after the delay
                    if tick() - lastTargetSwitchTime >= TARGET_SWITCH_DELAY then
                        currentTargetIndex = currentTargetIndex % #targets + 1
                        lastTargetSwitchTime = tick()
                    end
                end
                task.wait(TRIGGER_INTERVAL)
            end
        end)
    end

    local function stopTriggerLoop()
        if not triggerConnection then return end -- Not running
        isLooping = false
        loopButton.Text = "Start Loop"
        loopButton.BackgroundColor3 = Color3.fromRGB(0, 100, 0) -- Darker Green when inactive
        if triggerConnection then
            task.cancel(triggerConnection)
            triggerConnection = nil
        end
    end

    -- Loop Button functionality
    loopButton.MouseButton1Click:Connect(function()
        if isLooping then
            stopTriggerLoop()
        else
            startTriggerLoop()
        end
    end)

    -- Initial refresh
    refreshPlayerList()

    -- Auto-refresh player list every X seconds
    local refreshThread = task.spawn(function()
        while task.wait(UI_REFRESH_INTERVAL) do
            refreshPlayerList()
        end
    end)

    -- Make the auto farm UI draggable
    makeDraggable(mainFrame)

    -- Ensure the loop stops if the main frame is destroyed (e.g., player leaves or UI is closed)
    mainFrame.AncestryChanged:Connect(function(_, parent)
        if not parent and isLooping then -- Frame was removed from screenGui
            stopTriggerLoop()
            if refreshThread then
                task.cancel(refreshThread)
                refreshThread = nil
            end
            -- Don't destroy afToggleButton here, it's managed by hubGui.
        end
    end)

    -- Add a close button to the Auto Farm UI
    local autoFarmCloseButton = Instance.new("TextButton")
    autoFarmCloseButton.Size = UDim2.new(0, 20, 0, 20)
    autoFarmCloseButton.Position = UDim2.new(1, -25, 0, 5)
    autoFarmCloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    autoFarmCloseButton.Text = "X"
    autoFarmCloseButton.TextColor3 = Color3.new(1,1,1)
    autoFarmCloseButton.Font = Enum.Font.GothamBold
    autoFarmCloseButton.TextScaled = true
    autoFarmCloseButton.Parent = mainFrame
    autoFarmCloseButton.ZIndex = 2 -- Ensure it's above the anime girl

    local autoFarmCloseButtonCorner = Instance.new("UICorner")
    autoFarmCloseButtonCorner.CornerRadius = UDim.new(0, 5)
    autoFarmCloseButtonCorner.Parent = autoFarmCloseButton

    autoFarmCloseButton.MouseButton1Click:Connect(function()
        stopTriggerLoop() -- Ensure loop stops when closing
        if refreshThread then
            task.cancel(refreshThread)
            refreshThread = nil
        end
        autoFarmScreenGui.Enabled = false -- Just disable it
        if afToggleButton then afToggleButton.Visible = false end -- Hide its toggle button
    end)

    -- Create the 'af' toggle button if it doesn't exist and hubGui exists
    if not afToggleButton and hubGui then
        afToggleButton = Instance.new("TextButton")
        afToggleButton.Name = "AutoFarmToggleButton"
        afToggleButton.Size = UDim2.new(0, 40, 0, 40)
        afToggleButton.Position = UDim2.new(0.95, -45, 0.05, 50) -- Position below the main hub toggle
        afToggleButton.BackgroundColor3 = Color3.fromRGB(40, 160, 80) -- Darker greenish
        afToggleButton.TextColor3 = Color3.new(1,1,1)
        afToggleButton.Font = Enum.Font.GothamBold
        afToggleButton.Text = "AF" -- "AF" for Auto Farm
        afToggleButton.TextScaled = true
        afToggleButton.Parent = hubGui
        afToggleButton.Visible = autoFarmScreenGui.Enabled -- Match visibility of mainFrame

        local afToggleCorner = Instance.new("UICorner")
        afToggleCorner.CornerRadius = UDim.new(0, 20)
        afToggleCorner.Parent = afToggleButton

        makeDraggable(afToggleButton)

        afToggleButton.MouseButton1Click:Connect(function()
            mainFrame.Visible = not mainFrame.Visible
            autoFarmScreenGui.Enabled = mainFrame.Visible -- Keep ScreenGui enabled
        end)
    end
end
-- --- AUTO FARM FEATURE END ---


local function activateMainHub()
    -- Create a new, persistent ScreenGui for the hub and its toggle button
    hubGui = Instance.new("ScreenGui")
    hubGui.Name = "PguHubGui"
    hubGui.ResetOnSpawn = false
    hubGui.Parent = player:WaitForChild("PlayerGui")

    --- Main Hub Frame ---
    local mainHubFrame = Instance.new("Frame")
    mainHubFrame.Name = "MainHubFrame" -- Added name for easier reference
    mainHubFrame.Size = UDim2.new(0, 210, 0, 310) -- Adjusted size for 3x3 grid + discord
    mainHubFrame.Position = UDim2.new(0.5, -105, 0.5, -155) -- Adjust position
    mainHubFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Darker black
    mainHubFrame.BorderSizePixel = 0
    mainHubFrame.Visible = false -- Start hidden
    mainHubFrame.Parent = hubGui

    local hubCorner = Instance.new("UICorner", mainHubFrame)
    hubCorner.CornerRadius = UDim.new(0, 12)

    local hubStroke = Instance.new("UIStroke", mainHubFrame)
    hubStroke.Color = Color3.fromRGB(50, 50, 50) -- Darker stroke
    hubStroke.Thickness = 2

    makeDraggable(mainHubFrame)

    --- Hub Title ---
    local hubTitle = Instance.new("TextLabel", mainHubFrame)
    hubTitle.Size = UDim2.new(1, 0, 0, 25) -- Smaller title
    hubTitle.Position = UDim2.new(0, 0, 0, 5)
    hubTitle.BackgroundTransparency = 1
    hubTitle.TextColor3 = Color3.new(1, 1, 1)
    hubTitle.Font = Enum.Font.GothamBold
    hubTitle.TextSize = 18
    hubTitle.Text = "pgu's Hub"

    -- Close Button for Hub
    local hubCloseButton = Instance.new("TextButton", mainHubFrame)
    hubCloseButton.Size = UDim2.new(0, 20, 0, 20)
    hubCloseButton.Position = UDim2.new(1, -25, 0, 5)
    hubCloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    hubCloseButton.Text = "X"
    hubCloseButton.TextColor3 = Color3.new(1,1,1)
    hubCloseButton.Font = Enum.Font.GothamBold
    hubCloseButton.TextScaled = true
    hubCloseButton.Parent = mainHubFrame

    local hubCloseButtonCorner = Instance.new("UICorner")
    hubCloseButtonCorner.CornerRadius = UDim.new(0, 5)
    hubCloseButtonCorner.Parent = hubCloseButton

    hubCloseButton.MouseButton1Click:Connect(function()
        mainHubFrame.Visible = false
    end)


    -- Button Grid Container
    local buttonGrid = Instance.new("Frame", mainHubFrame)
    buttonGrid.Name = "ButtonGrid"
    buttonGrid.Size = UDim2.new(1, -20, 1, -80) -- Adjusted size to fit 3x3 and title/discord
    buttonGrid.Position = UDim2.new(0, 10, 0, 35) -- Position below title
    buttonGrid.BackgroundTransparency = 1
    buttonGrid.ClipsDescendants = true

    local gridLayout = Instance.new("UIGridLayout", buttonGrid)
    gridLayout.FillDirection = Enum.FillDirection.Horizontal
    gridLayout.CellPadding = UDim2.new(0, 5, 0, 5)
    gridLayout.CellSize = UDim2.new(0.33, -7, 0.33, -7) -- For a 3x3 layout (minus padding)
    gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top

    --- Feature Buttons (organized for 3x3) ---

    -- Force Pass Button
    local forcePassButton = Instance.new("TextButton", buttonGrid)
    forcePassButton.Name = "ForcePass"
    forcePassButton.BackgroundColor3 = Color3.fromRGB(180, 80, 30) -- Darker
    forcePassButton.TextColor3 = Color3.new(1, 1, 1)
    forcePassButton.Font = Enum.Font.GothamBold
    forcePassButton.TextSize = 10 -- Smaller text
    forcePassButton.Text = "Force Pass"
    local fpCorner = Instance.new("UICorner", forcePassButton)
    fpCorner.CornerRadius = UDim.new(0, 8)
    local fpNote = Instance.new("TextLabel", forcePassButton)
    fpNote.Size = UDim2.new(1, 0, 0.3, 0)
    fpNote.Position = UDim2.new(0, 0, 0.7, 0)
    fpNote.BackgroundTransparency = 1
    fpNote.TextColor3 = Color3.fromRGB(150, 150, 150) -- Darker note
    fpNote.Font = Enum.Font.SourceSans
    fpNote.TextSize = 8
    fpNote.Text = "(reo/kurona)"
    fpNote.TextXAlignment = Enum.TextXAlignment.Center

    forcePassButton.MouseButton1Click:Connect(function()
        pcall(function()
            local args = {
                [1] = "OneTwo",
                [2] = Players.LocalPlayer.Character
            }
            AbilityService.RE.Ability:FireServer(unpack(args))
            showPopupMessage("Force Pass executed!", 1.5, 0.5)
        end)
    end)

    -- GK Assist Toggle Button
    local gkAssistButton = Instance.new("TextButton", buttonGrid)
    gkAssistButton.Name = "GKAssist"
    gkAssistButton.BackgroundColor3 = Color3.fromRGB(200, 80, 0) -- Darker orange
    gkAssistButton.TextColor3 = Color3.new(1, 1, 1)
    gkAssistButton.Font = Enum.Font.GothamBold
    gkAssistButton.TextSize = 10 -- Smaller text
    gkAssistButton.Text = "GK Assist: Off"
    local gkSMSCorner = Instance.new("UICorner", gkAssistButton)
    gkSMSCorner.CornerRadius = UDim.new(0, 8)

    gkAssistButton.MouseButton1Click:Connect(function()
        setGKSphereVisibility(not gkAssistActive, gkAssistButton)
        showPopupMessage("GK Assist " .. (gkAssistActive and "Enabled" or "Disabled"), 1.5, 0.5)
    end)

    -- Fix Hitbox Button
    local fixHitboxButton = Instance.new("TextButton", buttonGrid)
    fixHitboxButton.Name = "FixHitbox"
    fixHitboxButton.BackgroundColor3 = Color3.fromRGB(120, 50, 160) -- Darker purple
    fixHitboxButton.TextColor3 = Color3.new(1, 1, 1)
    fixHitboxButton.Font = Enum.Font.GothamBold
    fixHitboxButton.TextSize = 10 -- Smaller text
    fixHitboxButton.Text = "Fix Hitbox: Off"
    local fixHitboxCorner = Instance.new("UICorner", fixHitboxButton)
    fixHitboxCorner.CornerRadius = UDim.new(0, 8)
    local fixHitboxNote = Instance.new("TextLabel", fixHitboxButton)
    fixHitboxNote.Size = UDim2.new(1, 0, 0.3, 0)
    fixHitboxNote.Position = UDim2.new(0, 0, 0.7, 0)
    fixHitboxNote.BackgroundTransparency = 1
    fixHitboxNote.TextColor3 = Color3.fromRGB(150, 150, 150) -- Darker note
    fixHitboxNote.Font = Enum.Font.SourceSans
    fixHitboxNote.TextSize = 8
    fixHitboxNote.Text = "(use until fixed)"
    fixHitboxNote.TextXAlignment = Enum.TextXAlignment.Center

    fixHitboxButton.MouseButton1Click:Connect(function()
        fixHitboxActive = not fixHitboxActive
        fixHitboxButton.Text = fixHitboxActive and "Fix Hitbox: On" or "Fix Hitbox: Off"
        fixHitboxButton.BackgroundColor3 = fixHitboxActive and Color3.fromRGB(60, 120, 60) or Color3.fromRGB(120, 50, 160)
        showPopupMessage("Fix Hitbox " .. (fixHitboxActive and "Enabled" or "Disabled"), 1.5, 0.5)
    end)

    -- No Cooldown Button
    local noCooldownButton = Instance.new("TextButton", buttonGrid)
    noCooldownButton.Name = "NoCooldown"
    noCooldownButton.BackgroundColor3 = Color3.fromRGB(30, 120, 150) -- Darker teal
    noCooldownButton.TextColor3 = Color3.new(1, 1, 1)
    noCooldownButton.Font = Enum.Font.GothamBold
    noCooldownButton.TextSize = 10 -- Smaller text
    noCooldownButton.Text = "No Cooldown"
    local noCDCorner = Instance.new("UICorner", noCooldownButton)
    noCDCorner.CornerRadius = UDim.new(0, 8)

    noCooldownButton.MouseButton1Click:Connect(function()
        local success, err = pcall(function()
            local NoCD = require(ReplicatedStorage.Controllers.AbilityController)
            local originalCooldown = NoCD.AbilityCooldown

            NoCD.AbilityCooldown = function(self, name, ...)
                return originalCooldown(self, name, 0, ...)
            end
        end)
        if success then
            showPopupMessage("No Cooldown Enabled!", 2, 0.5)
            noCooldownButton.Text = "No Cooldown Active!"
            noCooldownButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60) -- Change color to indicate active
            noCooldownButton.Active = false -- Make it unclickable after enabling
        else
            showPopupMessage("Failed to enable No Cooldown: " .. err, 3, 0.5)
        end
    end)

    -- Lock Stamina Button
    local lockStaminaButton = Instance.new("TextButton", buttonGrid)
    lockStaminaButton.Name = "LockStamina"
    lockStaminaButton.BackgroundColor3 = Color3.fromRGB(80, 80, 160) -- Darker blue
    lockStaminaButton.TextColor3 = Color3.new(1, 1, 1)
    lockStaminaButton.Font = Enum.Font.GothamBold
    lockStaminaButton.TextSize = 10 -- Smaller text
    lockStaminaButton.Text = "Lock Stamina"
    local lockStaminaCorner = Instance.new("UICorner", lockStaminaButton)
    lockStaminaCorner.CornerRadius = UDim.new(0, 8)

    lockStaminaButton.MouseButton1Click:Connect(function()
        if not staminaLockActive then
            staminaLockActive = true
            lockStaminaButton.Text = "Stamina Locked"
            lockStaminaButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60) -- Green
            local playerStats = player:FindFirstChild("PlayerStats")
            if playerStats then
                local staminaValue = playerStats:FindFirstChild("Stamina")
                if staminaValue and staminaValue:IsA("NumberValue") then
                    staminaValue.Value = 100 -- Set initial value
                    -- Connect to Changed event to continuously lock
                    local connection = staminaValue.Changed:Connect(function(newVal)
                        if staminaLockActive and newVal ~= 100 then
                            staminaValue.Value = 100
                        end
                    end)
                    -- Disconnect the continuous lock when the character is removed or player leaves
                    player.CharacterRemoving:Connect(function()
                        if connection then connection:Disconnect() end
                    end)
                    player.AncestryChanged:Connect(function() -- For player leaving
                        if not player:IsDescendantOf(game) then
                            if connection then connection:Disconnect() end
                        end
                    end)
                    showPopupMessage("Stamina Locked to 100!", 1.5, 0.5)
                else
                    showPopupMessage("Stamina value not found or is not a NumberValue.", 2, 0.5)
                    staminaLockActive = false -- Reset if not found
                    lockStaminaButton.Text = "Lock Stamina"
                    lockStaminaButton.BackgroundColor3 = Color3.fromRGB(80, 80, 160)
                end
            else
                showPopupMessage("PlayerStats folder not found.", 2, 0.5)
                staminaLockActive = false -- Reset if not found
                lockStaminaButton.Text = "Lock Stamina"
                lockStaminaButton.BackgroundColor3 = Color3.fromRGB(80, 80, 160)
            end
        else -- If already active, this means it's being clicked to disable
            staminaLockActive = false
            lockStaminaButton.Text = "Lock Stamina"
            lockStaminaButton.BackgroundColor3 = Color3.fromRGB(80, 80, 160)
            showPopupMessage("Stamina Lock Disabled!", 1.5, 0.5)
            -- The connection for continuously locking will be handled by CharacterRemoving/AncestryChanged,
            -- so we just need to flip the state and text here.
        end
    end)

    -- Player Line Toggle Button
    local playerLineButton = Instance.new("TextButton", buttonGrid)
    playerLineButton.Name = "PlayerLine"
    playerLineButton.BackgroundColor3 = Color3.fromRGB(160, 80, 40) -- Darker orange
    playerLineButton.TextColor3 = Color3.new(1, 1, 1)
    playerLineButton.Font = Enum.Font.GothamBold
    playerLineButton.TextSize = 10 -- Smaller text
    playerLineButton.Text = "Player Line: Off"
    local plCorner = Instance.new("UICorner", playerLineButton)
    plCorner.CornerRadius = UDim.new(0, 8)

    playerLineButton.MouseButton1Click:Connect(function()
        playerLineEnabled = not playerLineEnabled
        if playerLineEnabled then
            -- Iterate through all existing players and set up tracking
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= player then -- Exclude local player as per your request
                    setupPlayerHasBallTracking(p)
                end
            end
            -- Connect to PlayerAdded for future players
            Players.PlayerAdded:Connect(function(newPlayer)
                if newPlayer ~= player then
                    setupPlayerHasBallTracking(newPlayer)
                end
            end)
            -- Connect to PlayerRemoving to clean up
            Players.PlayerRemoving:Connect(function(leavingPlayer)
                cleanupPlayerHasBallTracking(leavingPlayer)
            end)
            showPopupMessage("Player Lines Enabled!", 1.5, 0.5)
        else
            -- Disable and remove all active lines
            for p, _ in pairs(clientPlayerLines) do
                removeClientPlayerGazeLine(p)
            end
            -- Clean up all tracking connections
            for p, conns in pairs(hasBallConnections) do
                for _, conn in pairs(conns) do
                    conn:Disconnect()
                end
            end
            hasBallConnections = {} -- Reset the table
            showPopupMessage("Player Lines Disabled!", 1.5, 0.5)
        end
        playerLineButton.Text = playerLineEnabled and "Player Line: On" or "Player Line: Off"
        playerLineButton.BackgroundColor3 = playerLineEnabled and Color3.fromRGB(60, 120, 60) or Color3.fromRGB(160, 80, 40)
    end)

    -- Auto Dribble Toggle Button
    local autoDribbleButton = Instance.new("TextButton", buttonGrid)
    autoDribbleButton.Name = "AutoDribble"
    autoDribbleButton.BackgroundColor3 = Color3.fromRGB(140, 120, 30) -- Darker yellow/brown
    autoDribbleButton.TextColor3 = Color3.new(1, 1, 1)
    autoDribbleButton.Font = Enum.Font.GothamBold
    autoDribbleButton.TextSize = 10 -- Smaller text
    autoDribbleButton.Text = "Auto Dribble: Off"
    local adCorner = Instance.new("UICorner", autoDribbleButton)
    adCorner.CornerRadius = UDim.new(0, 8)

    autoDribbleButton.MouseButton1Click:Connect(function()
        AutoDribbleSettings.Enabled = not AutoDribbleSettings.Enabled
        autoDribbleButton.Text = AutoDribbleSettings.Enabled and "Auto Dribble: On" or "Auto Dribble: Off"
        autoDribbleButton.BackgroundColor3 = AutoDribbleSettings.Enabled and Color3.fromRGB(60, 120, 60) or Color3.fromRGB(140, 120, 30)
        showPopupMessage("Auto Dribble " .. (AutoDribbleSettings.Enabled and "Enabled" or "Disabled"), 1.5, 0.5)
    end)

    -- Auto Farm Button (New Feature)
    local autoFarmButton = Instance.new("TextButton", buttonGrid)
    autoFarmButton.Name = "AutoFarmButton"
    autoFarmButton.BackgroundColor3 = Color3.fromRGB(40, 160, 80) -- Darker greenish color for new feature
    autoFarmButton.TextColor3 = Color3.new(1, 1, 1)
    autoFarmButton.Font = Enum.Font.GothamBold
    autoFarmButton.TextSize = 10 -- Smaller text
    autoFarmButton.Text = "Auto Farm"
    local afCorner = Instance.new("UICorner", autoFarmButton)
    afCorner.CornerRadius = UDim.new(0, 8)

    autoFarmButton.MouseButton1Click:Connect(function()
        activateAutoFarm()
        showPopupMessage("Auto Farm UI Toggled!", 1.5, 0.5)
        -- mainHubFrame.Visible = false -- No longer auto-hide main hub, it's independent
    end)


    --- Hub Discord Button (moved to the bottom of the main frame, outside grid) ---
    local hubDiscordButton = Instance.new("TextButton", mainHubFrame)
    hubDiscordButton.Size = UDim2.new(1, -20, 0, 30) -- Stretched button
    hubDiscordButton.Position = UDim2.new(0, 10, 1, -40) -- Position at the bottom of the main frame
    hubDiscordButton.BackgroundColor3 = Color3.fromRGB(50, 70, 180) -- Darker blue/purple
    hubDiscordButton.TextColor3 = Color3.new(1,1,1)
    hubDiscordButton.Font = Enum.Font.GothamBold
    hubDiscordButton.TextSize = 14
    hubDiscordButton.Text = "Join Discord"
    local hdCorner = Instance.new("UICorner", hubDiscordButton)
    hdCorner.CornerRadius = UDim.new(0, 8)

    hubDiscordButton.MouseButton1Click:Connect(function()
        local success, err = pcall(function()
            setclipboard("https://discord.gg/Wy7Mhhgn3h")
        end)
        hubDiscordButton.Text = success and "Copied!" or "Failed to copy"
        task.wait(2)
        hubDiscordButton.Text = "Join Discord"
    end)

    --- Infinite Stamina Lock (Consider removing this if redundant with the new Lock Stamina button) ---
    local staminaLock = Instance.new("BoolValue")
    staminaLock.Name = "InfiniteStamina"
    staminaLock.Value = true
    staminaLock.Parent = player

    --- Hub Toggle Button ---
    local hubToggleButton = Instance.new("TextButton")
    hubToggleButton.Name = "HubToggleButton" -- Add a name for easier lookup
    hubToggleButton.Size = UDim2.new(0, 40, 0, 40) -- Smaller toggle button
    hubToggleButton.Position = UDim2.new(0.95, -45, 0.05, 5)
    hubToggleButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20) -- Darker
    hubToggleButton.TextColor3 = Color3.new(1, 1, 1)
    hubToggleButton.Font = Enum.Font.GothamBold
    hubToggleButton.Text = "Hub"
    hubToggleButton.TextScaled = true
    hubToggleButton.Parent = hubGui
    hubToggleButton.Visible = false -- Initially hidden

    local hubToggleCorner = Instance.new("UICorner")
    hubToggleCorner.CornerRadius = UDim.new(0, 20)
    hubToggleCorner.Parent = hubToggleButton

    makeDraggable(hubToggleButton) -- Make the hub toggle button draggable

    hubToggleButton.MouseButton1Click:Connect(function()
        mainHubFrame.Visible = not mainHubFrame.Visible
        -- Don't close Auto Farm when opening Hub; they are now independent.
        -- If afToggleButton exists, make sure its visibility is kept consistent
        if afToggleButton then
            afToggleButton.Visible = autoFarmScreenGui and autoFarmScreenGui.Enabled -- Make AF toggle visible if AF GUI is enabled
        end
    end)
end

local function initializeVisuals()
    player.CharacterAdded:Connect(onCharacterAdded)
    createGKSphere() -- Create the sphere for GK Assist
    RunService.RenderStepped:Connect(updateGKSphereAndTrigger) -- Update sphere position and trigger
    RunService.Heartbeat:Connect(updateHitbox)
    RunService.RenderStepped:Connect(updateTrail)
    RunService.RenderStepped:Connect(updateAllClientPlayerGazeLines) -- Update all client-side lines
end

-- Make visuals initially invisible
local function hideVisuals()
    setGKSphereVisibility(false) -- Hide GK Sphere initially
    -- Also hide all client-side player gaze lines
    for p, _ in pairs(clientPlayerLines) do
        removeClientPlayerGazeLine(p)
    end
end

-- Key check function
checkButton.MouseButton1Click:Connect(function()
    local enteredKey = keyBox.Text
    local success = verifyKey(enteredKey) -- Use Platoboost's verifyKey

    if success then
        screenGui:Destroy()
        showPopupMessage("Key Accepted! Hub loaded.", 3, 1)
        -- Activate main hub features
        activateMainHub()
        if hubGui then
            -- Wait for the HubToggleButton to be a child of hubGui before making it visible and draggable
            local hubToggleButton = hubGui:WaitForChild("HubToggleButton")
            hubToggleButton.Visible = true -- Show hub toggle button
        end
        initializeVisuals()
    else
        -- onMessage will handle the popup message for invalid key
    end
end)

-- Initialize and hide visuals
hideVisuals()

